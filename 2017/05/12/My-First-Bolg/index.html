<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>WebView 全面使用攻略 | 待到山花烂漫时</title>
  <meta name="author" content="EteVan">
  
  <meta name="description" content="原文链接：http://blog.csdn.net/qq_17766199/article/details/71698593史上最全 WebView 使用，附送 Html5Activity 一份 —— 由唯鹿分享关于WebView使用很全面的一篇文章，分享给大家。原文链接在此文中我会有部分补充乱入。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="WebView 全面使用攻略"/>
  <meta property="og:site_name" content="待到山花烂漫时"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link rel="alternate" href="/etevan.github.io/atom.xml" title="待到山花烂漫时" type="application/atom+xml">
  <link rel="stylesheet" href="/etevan.github.io/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!-- wumiiVerification -->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/etevan.github.io/favicon.ico">
  <!-- Font-Awesome -->
  <link rel="stylesheet" href="/etevan.github.io/font-awesome/css/font-awesome.min.css">

</head>

<body>
  <header id="header"><div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/img/default/avatar.png">
              </div>
		
		<div class="header-div">
		    <h1><a href="/etevan.github.io/">待到山花烂漫时</a></h1>
		    <h2><a href="/etevan.github.io/"></a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
		    		
		    		  <a href="/"><i class="fa fa-home"></i>首页</a>
		    		
		    		  <a href="/archives"><i class="fa fa-archive"></i>归档</a>
		    		
		    		  <a href="/hexo"><i class="fa fa-book"></i>电子书</a>
		    		
		    		  <a href="/resume"><i class="fa fa-user"></i>关于我</a>
		    		
		</div>
		<div id="sub-nav" class="alignright">
		    
		      <a href="/atom.xml"><i class="fa fa-rss"></i>订阅</a>
		    
		      <a href="/customization"><i class="fa fa-question-circle"></i>留言</a>
		    
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2017-05-12T01:51:38.000Z"><a href="/etevan.github.io/2017/05/12/My-First-Bolg/">2017-05-12</a></time>
        
  
    <h1 class="title">WebView 全面使用攻略</h1>
  

    </header>

    <div class="entry">
      
        
    <div id="toc">
        
    </div>

        <p>原文链接：<a href="http://blog.csdn.net/qq_17766199/article/details/71698593" target="_blank" rel="external">http://blog.csdn.net/qq_17766199/article/details/71698593</a><br>史上最全 WebView 使用，附送 Html5Activity 一份 —— 由唯鹿分享<br>关于WebView使用很全面的一篇文章，分享给大家。原文链接在此<br>文中我会有部分补充乱入。<br>WebView在现在的项目中使用的频率应该还是非常高的。<br>我个人总觉得HTML5是一种趋势。找了一些东西，在此总结。<br>本篇最后有一个非常不错 的 Html5Activity 加载类，不想看的可以直接跳下载。</p>
<p>WebSettings</p>
<p>WebSettings webSettings = mWebView .getSettings();</p>
<p>//支持获取手势焦点，输入用户名、密码或其他<br>webview.requestFocusFromTouch();</p>
<p>setJavaScriptEnabled(true);  //支持js<br>setPluginsEnabled(true);  //支持插件</p>
<p>webSettings.setRenderPriority(RenderPriority.HIGH);  //提高渲染的优先级</p>
<p>设置自适应屏幕，两者合用<br>setUseWideViewPort(true);  //将图片调整到适合webview的大小<br>setLoadWithOverviewMode(true); // 缩放至屏幕的大小</p>
<p>setSupportZoom(true);  //支持缩放，默认为true。是下面那个的前提。<br>setBuiltInZoomControls(true); //设置内置的缩放控件。<br>//若上面是false，则该WebView不可缩放，这个不管设置什么都不能缩放。<br>setTextZoom(2);//设置文本的缩放倍数，默认为 100</p>
<p>setDisplayZoomControls(false); //隐藏原生的缩放控件</p>
<p>setLayoutAlgorithm(LayoutAlgorithm.SINGLE_COLUMN); //支持内容重新布局<br>supportMultipleWindows();  //多窗口<br>setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);  //关闭webview中缓存<br>setAllowFileAccess(true);  //设置可以访问文件<br>setNeedInitialFocus(true); //当webview调用requestFocus时为webview设置节点<br>setJavaScriptCanOpenWindowsAutomatically(true); //支持通过JS打开新窗口<br>setLoadsImagesAutomatically(true);  //支持自动加载图片<br>setDefaultTextEncodingName(“utf-8”);//设置编码格式</p>
<p>setStandardFontFamily(“”);//设置 WebView 的字体，默认字体为 “sans-serif”<br>setDefaultFontSize(20);//设置 WebView 字体的大小，默认大小为 16<br>setMinimumFontSize(12);//设置 WebView 支持的最小字体大小，默认为 8<br>关于缓存</p>
<p>缓存模式</p>
<p>LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据<br>LOAD_DEFAULT: （默认）根据cache-control决定是否从网络上取数据。<br>LOAD_NO_CACHE: 不使用缓存，只从网络获取数据.<br>LOAD_CACHE_ELSE_NETWORK，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p>
<p>结合使用（离线加载）：</p>
<p>if (NetStatusUtil.isConnected(getApplicationContext())) {<br>    webSettings.setCacheMode(WebSettings.LOAD_DEFAULT);//根据cache-control决定是否从网络上取数据。<br>} else {<br>    webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);//没网，则从本地获取，即离线加载<br>}</p>
<p>webSettings.setDomStorageEnabled(true); // 开启 DOM storage API 功能<br>webSettings.setDatabaseEnabled(true);   //开启 database storage API 功能<br>webSettings.setAppCacheEnabled(true);//开启 Application Caches 功能</p>
<p>String cacheDirPath = getFilesDir().getAbsolutePath() + APP_CACAHE_DIRNAME;<br>webSettings.setAppCachePath(cacheDirPath); //设置  Application Caches 缓存目录<br>注意： 每个 Application 只调用一次 WebSettings.setAppCachePath()，WebSettings.setAppCacheMaxSize()</p>
<p>加载方式</p>
<p>加载一个网页：</p>
<p>webView.loadUrl(“<a href="http://www.google.com/" target="_blank" rel="external">http://www.google.com/</a>“);<br>加载apk包中的一个html页面</p>
<p>webView.loadUrl(“file:///android_asset/test.html”);<br>加载手机本地的一个html页面的方法：</p>
<p>webView.loadUrl(“content://com.android.htmlfileprovider/sdcard/test.html”);<br>添加 HTTP 请求头(Header)</p>
<p>loadUrl(String url, Map<string, string=""> additionalHttpHeaders)<br>WebViewClient</string,></p>
<p>WebViewClient就是帮助WebView处理各种通知、请求事件的。<br>打开网页时不调用系统浏览器， 而是在本WebView中显示：</p>
<p>mWebView.setWebViewClient(new WebViewClient(){<br>      @Override<br>      public boolean shouldOverrideUrlLoading(WebView view, String url) {<br>          view.loadUrl(url);<br>      return true;<br>      }<br>  });<br>WebViewClient方法</p>
<p>WebViewClient mWebViewClient = new WebViewClient()<br>{<br>    shouldOverrideUrlLoading(WebView view, String url)  最常用的，比如上面的。<br>    //在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。<br>    //比如获取url，查看url.contains(“add”)，进行添加操作</p>
<pre><code>shouldOverrideKeyEvent(WebView view, KeyEvent event)
//重写此方法才能够处理在浏览器中的按键事件。

onPageStarted(WebView view, String url, Bitmap favicon)
//这个事件就是开始载入页面调用的，我们可以设定一个loading的页面，告诉用户程序在等待网络响应。

onPageFinished(WebView view, String url)
//在页面加载结束时调用。同样道理，我们可以关闭loading 条，切换程序动作。

onLoadResource(WebView view, String url)
// 在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。

shouldInterceptRequest(WebView view, String url)
// 拦截替换网络请求数据,  API 11开始引入，API 21弃用
shouldInterceptRequest (WebView view, WebResourceRequest request)
// 拦截替换网络请求数据,  从API 21开始引入

onReceivedError(WebView view, int errorCode, String description, String failingUrl)
// (报告错误信息)

doUpdateVisitedHistory(WebView view, String url, boolean isReload)
//(更新历史记录)

onFormResubmission(WebView view, Message dontResend, Message resend)
//(应用程序重新请求网页数据)

onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host,String realm)
//（获取返回信息授权请求）

onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)
//重写此方法可以让webview处理https请求。

onScaleChanged(WebView view, float oldScale, float newScale)
// (WebView发生改变时调用)

onUnhandledKeyEvent(WebView view, KeyEvent event)
//（Key事件未被加载时调用）
</code></pre><p>}<br>将上面定义的WebViewClient设置给WebView：</p>
<p>webView.setWebViewClient(mWebViewClient);<br>WebChromeClient</p>
<p>WebChromeClient是辅助WebView处理JavaScript的对话框，网站图标，网站title，加载进度等 :<br>方法中的代码都是由 Android端自己处理。</p>
<p>WebChromeClient mWebChromeClient = new WebChromeClient() {</p>
<pre><code>//获得网页的加载进度，显示在右上角的TextView控件中
@Override
public void onProgressChanged(WebView view, int newProgress) {
    if (newProgress &lt; 100) {
        String progress = newProgress + &quot;%&quot;;
    } else {
    }
}

//获取Web页中的title用来设置自己界面中的title
//当加载出错的时候，比如无网络，这时onReceiveTitle中获取的标题为 找不到该网页,
//因此建议当触发onReceiveError时，不要使用获取到的title
@Override
public void onReceivedTitle(WebView view, String title) {
    MainActivity.this.setTitle(title);
}

@Override
public void onReceivedIcon(WebView view, Bitmap icon) {
    //
}

@Override
public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
    //
    return true;
}

@Override
public void onCloseWindow(WebView window) {
}

//处理alert弹出框，html 弹框的一种方式
@Override
public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
    //
    return true;
}

//处理confirm弹出框
@Override
public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult
        result) {
    //
    return true;
}

//处理prompt弹出框
@Override
public boolean onJsConfirm(WebView view, String url, String message, JsResult result) {
    //
    return true;
}
</code></pre><p>};<br>同样，将上面定义的WebChromeClient设置给WebView：</p>
<p>webView.setWebChromeClient(mWebChromeClient);<br>WebView 的一些方法</p>
<p>前进、后退</p>
<p>goBack()//后退<br>goForward()//前进<br>goBackOrForward(intsteps) //以当前的index为起始点前进或者后退到历史记录中指定的steps，如果steps为负数则为后退，正数则为前进<br>canGoForward()//是否可以前进<br>canGoBack() //是否可以后退<br>清除缓存数据：</p>
<p>clearCache(true);//清除网页访问留下的缓存，由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序.<br>clearHistory()//清除当前webview访问的历史记录，只会webview访问历史记录里的所有记录除了当前访问记录.<br>clearFormData()//这个api仅仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据。<br>WebView的状态：</p>
<p>onResume() //激活WebView为活跃状态，能正常执行网页的响应<br>onPause()//当页面被失去焦点被切换到后台不可见状态，需要执行onPause动过， onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。</p>
<p>pauseTimers()//当应用程序被切换到后台我们使用了webview， 这个方法不仅仅针对当前的webview而是全局的全应用程序的webview，它会暂停所有webview的layout，parsing，javascripttimer。降低CPU功耗。<br>resumeTimers()//恢复pauseTimers时的动作。</p>
<p>destroy()//销毁，关闭了Activity时，音乐或视频，还在播放。就必须销毁。<br>但是注意：<br>webview调用destory时,webview仍绑定在Activity上.这是由于自定义webview构建时传入了该Activity的context对象,因此需要先从父容器中移除webview,然后再销毁webview:</p>
<p>rootLayout.removeView(webView);<br>webView.destroy();<br>判断WebView是否已经滚动到页面底端 或者 顶端:</p>
<p>getScrollY() //方法返回的是当前可见区域的顶端距整个页面顶端的距离,也就是当前内容滚动的距离.<br>getHeight()或者getBottom() //方法都返回当前WebView这个容器的高度<br>getContentHeight()返回的是整个html的高度,但并不等同于当前整个页面的高度,因为WebView有缩放功能,所以当前整个页面的高度实际上应该是原始html的高度再乘上缩放比例.因此,更正后的结果,准确的判断方法应该是：</p>
<pre><code>if (webView.getContentHeight() * webView.getScale() == (webView.getHeight() + webView.getScrollY())) {
    //已经处于底端
}

if(webView.getScrollY() == 0){
    //处于顶端
}
</code></pre><p>返回键</p>
<p>返回上一次浏览的页面</p>
<p>public boolean onKeyDown(int keyCode, KeyEvent event) {<br>    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) {<br>        mWebView.goBack();<br>        return true;<br>    }<br>    return super.onKeyDown(keyCode, event);<br>}<br>调用JS代码</p>
<p>  WebSettings webSettings = mWebView .getSettings();<br>  webSettings.setJavaScriptEnabled(true);</p>
<p>  mWebView.addJavascriptInterface(new InsertObj(), “jsObj”);<br>上面这是前提！！！<br>然后实现上面的类，这个类提供了四个方法，注释的非常清楚。</p>
<p>class InsertObj extends Object {<br>    //给html提供的方法，js中可以通过：var str = window.jsObj.HtmlcallJava(); 获取到<br>    @JavascriptInterface<br>    public String HtmlcallJava() {<br>        return “Html call Java”;<br>    }</p>
<pre><code>//给html提供的有参函数 ： window.jsObj.HtmlcallJava2(&quot;IT-homer blog&quot;);
@JavascriptInterface
public String HtmlcallJava2(final String param) {
    return &quot;Html call Java : &quot; + param;
}

//Html给我们提供的函数
@JavascriptInterface
public void JavacallHtml() {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            //这里是调用方法
            mWebView.loadUrl(&quot;javascript: showFromHtml()&quot;);
            Toast.makeText(Html5Activity.this, &quot;clickBtn&quot;, Toast.LENGTH_SHORT).show();
        }
    });
}

//Html给我们提供的有参函数
@JavascriptInterface
public void JavacallHtml2(final String param) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            mWebView.loadUrl(&quot;javascript: showFromHtml2(&apos;IT-homer blog&apos;)&quot;);
            Toast.makeText(Html5Activity.this, &quot;clickBtn2&quot;, Toast.LENGTH_SHORT).show();
        }
    });
}
</code></pre><p>}<br>Android 调用js有个漏洞：</p>
<p><a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">http://blog.csdn.net/leehong2005/article/details/11808557</a></p>
<p>这里我建议大家可以使用腾讯的X5内核</p>
<p>Android5.0 WebView中Http和Https混合问题</p>
<p>在Android 5.0上 Webview 默认不允许加载 Http 与 Https 混合内容：</p>
<p>解决办法：</p>
<p>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {<br>     webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);<br>}<br>参数类型说明：<br>MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；<br>MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；<br>MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。</p>
<p>在5.0以下 Android 默认是 全允许，<br>但是到了5.0以上，就是不允许，实际情况下很我们很难确定所有的网页都是https的，所以就需要这一步的操作。</p>
<p>在这里在分享一个：WebView加载https页面不能正常显示资源问题<br>文章里有：设置 WebView 接受所有网站的证书</p>
<p>Cookie 相关</p>
<p>之前同步 cookie 需要用到 CookieSyncManager 类，现在这个类已经被抛弃了。如今 WebView 已经可以在需要的时候自动同步 cookie 了，所以不再需要创建 CookieSyncManager 类的对象来进行强制性的同步 cookie 了。现在只需要获得 CookieManager 的对象将 cookie 设置进去就可以了。</p>
<p>前提：从服务器的返回头中取出 cookie 根据Http请求的客户端不同，获取 cookie 的方式也不同，请自行获取。</p>
<p>1、客户端通过以下代码设置cookie，如果两次设置相同，会覆盖上一次的。</p>
<p>/**</p>
<ul>
<li>将cookie设置到 WebView</li>
<li>@param url 要加载的 url</li>
<li>@param cookie 要同步的 cookie<br>*/<br>public static void syncCookie(String url,String cookie) {<br> if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) {<pre><code>CookieSyncManager.createInstance(context);
</code></pre> }<br> CookieManager cookieManager = CookieManager.getInstance();<br> cookieManager.setCookie(url, cookie);//如果没有特殊需求，这里只需要将session id以”key=value”形式作为cookie即可<br>}<br>注意：<br>1。同步 cookie 要在 WebView 加载 url 之前，否则 WebView 无法获得相应的 cookie，也就无法通过验证。<br>2。cookie应该被及时更新，否则很可能导致WebView拿的是旧的session id和服务器进行通信。<br>2、CookieManager会将这个Cookie存入该应用程序data/data/package_name/app_WebView/Cookies.db</li>
</ul>
<p>3、打开网页，WebView从数据库中读取该cookie值，放到http请求的头部，传递到服务器</p>
<p>/**</p>
<ul>
<li>获取指定 url 的cookie<br>*/<br>public static String syncCookie(String url) {<br> CookieManager cookieManager = CookieManager.getInstance();<br> return cookieManager.getCookie(url);<br>}<br>4、清除Cookie:</li>
</ul>
<p>// 这个两个在 API level 21 被抛弃<br>CookieManager.getInstance().removeSessionCookie();<br>CookieManager.getInstance().removeAllCookie();</p>
<p>// 推荐使用这两个， level 21 新加的<br>CookieManager.getInstance().removeSessionCookies();// 移除所有过期 cookie<br>CookieManager.getInstance().removeAllCookies(); // 移除所有的 cookie<br>private void removeCookie(Context context) {<br>    CookieManager.getInstance().removeAllCookies(new ValueCallback<boolean>() {<br>        @Override<br>        public void onReceiveValue(Boolean value) {<br>            // 清除结果<br>        }<br>    });<br>}<br>这里我补充一下，我们可以看到移除Cookie是移除所有的，所以更新你自己使用的url的cookie的话，不用清除cookie，只要再次setCookie，就会自动替换掉。毕竟cookie多了，直接清空会影响别的地方。具体我们可以去查看setCookie源码。<br>避免WebView内存泄露的一些方式</boolean></p>
<p>1.可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程；<br>启动新进程，主要代码： AndroidManifest.xml 配置文件代码如下</p>
<pre><code>&lt;activity
    android:name=&quot;.ui.activity.Html5Activity&quot;
    android:process=&quot;:lyl.boon.process.web&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.lyl.boon.ui.activity.htmlactivity&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>在新进程中启动 Activity ，里面传了 一个 Url：</p>
<pre><code>Intent intent = new Intent(&quot;com.lyl.boon.ui.activity.htmlactivity&quot;);
Bundle bundle = new Bundle();
bundle.putString(&quot;url&quot;, gankDataEntity.getUrl());
intent.putExtra(&quot;bundle&quot;,bundle);
startActivity(intent);
</code></pre><p>然后在 Html5Activity 的onDestory() 最后加上 System.exit(0); 杀死当前进程。</p>
<p>2.不能在xml中定义 Webview ，而是在需要的时候创建，并且Context使用 getApplicationgContext()，如下代码：</p>
<pre><code>LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
mWebView = new WebView(getApplicationContext());
mWebView.setLayoutParams(params);
mLayout.addView(mWebView);
</code></pre><p>3.在 Activity 销毁的时候，可以先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。<br>代码如下：</p>
<pre><code>@Override
protected void onDestroy() {
    if (mWebView != null) {
        mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
        mWebView.clearHistory();

        ((ViewGroup) mWebView.getParent()).removeView(mWebView);
        mWebView.destroy();
        mWebView = null;
    }
    super.onDestroy();
}
</code></pre><p>Html5Activity 加载类</p>
<p>public class Html5Activity extends AppCompatActivity {</p>
<pre><code>private String mUrl;

private LinearLayout mLayout;
private WebView mWebView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_web);

    Bundle bundle = getIntent().getBundleExtra(&quot;bundle&quot;);
    mUrl = bundle.getString(&quot;url&quot;);

    Log.d(&quot;Url:&quot;, mUrl);

    mLayout = (LinearLayout) findViewById(R.id.web_layout);


    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
    mWebView = new WebView(getApplicationContext());
    mWebView.setLayoutParams(params);
    mLayout.addView(mWebView);

    WebSettings mWebSettings = mWebView.getSettings();
    mWebSettings.setSupportZoom(true);
    mWebSettings.setLoadWithOverviewMode(true);
    mWebSettings.setUseWideViewPort(true);
    mWebSettings.setDefaultTextEncodingName(&quot;utf-8&quot;);
    mWebSettings.setLoadsImagesAutomatically(true);

    //调用JS方法.安卓版本大于17,加上注解 @JavascriptInterface
    mWebSettings.setJavaScriptEnabled(true);

    saveData(mWebSettings);

    newWin(mWebSettings);

    mWebView.setWebChromeClient(webChromeClient);
    mWebView.setWebViewClient(webViewClient);
    mWebView.loadUrl(mUrl);
}

@Override
public void onPause() {
    super.onPause();
    webView.onPause();
    webView.pauseTimers(); //小心这个！！！暂停整个 WebView 所有布局、解析、JS。
}

@Override
public void onResume() {
    super.onResume();
    webView.onResume();
    webView.resumeTimers();
}

/**
 * 多窗口的问题
 */
private void newWin(WebSettings mWebSettings) {
    //html中的_bank标签就是新建窗口打开，有时会打不开，需要加以下
    //然后 复写 WebChromeClient的onCreateWindow方法
    mWebSettings.setSupportMultipleWindows(false);
    mWebSettings.setJavaScriptCanOpenWindowsAutomatically(true);
}

/**
 * HTML5数据存储
 */
private void saveData(WebSettings mWebSettings) {
    //有时候网页需要自己保存一些关键数据,Android WebView 需要自己设置
    mWebSettings.setDomStorageEnabled(true);
    mWebSettings.setDatabaseEnabled(true);
    mWebSettings.setAppCacheEnabled(true);
    String appCachePath = getApplicationContext().getCacheDir().getAbsolutePath();
    mWebSettings.setAppCachePath(appCachePath);
}

WebViewClient webViewClient = new WebViewClient(){

    /**
     * 多页面在同一个WebView中打开，就是不新建activity或者调用系统浏览器打开
     */
    @Override
    public boolean shouldOverrideUrlLoading(WebView view, String url) {
        view.loadUrl(url);
        return true;
    }

};

WebChromeClient webChromeClient = new WebChromeClient() {

    //=========HTML5定位==========================================================
    //需要先加入权限
    //&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
    //&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;
    //&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;
    @Override
    public void onReceivedIcon(WebView view, Bitmap icon) {
        super.onReceivedIcon(view, icon);
    }

    @Override
    public void onGeolocationPermissionsHidePrompt() {
        super.onGeolocationPermissionsHidePrompt();
    }

    @Override
    public void onGeolocationPermissionsShowPrompt(final String origin, final GeolocationPermissions.Callback callback) {
        callback.invoke(origin, true, false);//注意个函数，第二个参数就是是否同意定位权限，第三个是是否希望内核记住
        super.onGeolocationPermissionsShowPrompt(origin, callback);
    }
    //=========HTML5定位==========================================================

    //=========多窗口的问题==========================================================
    @Override
    public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) {
        WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj;
        transport.setWebView(view);
        resultMsg.sendToTarget();
        return true;
    }
    //=========多窗口的问题==========================================================
};

@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; mWebView.canGoBack()) {
        mWebView.goBack();
        return true;
    }

    return super.onKeyDown(keyCode, event);
}

@Override
protected void onDestroy() {
    super.onDestroy();

    if (mWebView != null) {
        mWebView.clearHistory();
        ((ViewGroup) mWebView.getParent()).removeView(mWebView);
        mWebView.loadUrl(&quot;about:blank&quot;);
        mWebView.stopLoading();
        mWebView.setWebChromeClient(null);
        mWebView.setWebViewClient(null);
        mWebView.destroy();
        mWebView = null;
    }
}
</code></pre><p>}</p>

      
    </div>
    <footer>
      
        
        
        <div class = "counter">
  <span id="busuanzi_container_page_pv" style="display:none">
      总访问&nbsp<span id="busuanzi_value_page_pv"></span>&nbsp次
  </span>
</div>
        
  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a title="分享到QQ空间" href="#" class="bds_qzone" data-cmd="qzone"></a><a title="分享到新浪微博" href="#" class="bds_tsina" data-cmd="tsina"></a><a title="分享到腾讯微博" href="#" class="bds_tqq" data-cmd="tqq"></a><a title="分享到人人网" href="#" class="bds_renren" data-cmd="renren"></a><a title="分享到微信" href="#" class="bds_weixin" data-cmd="weixin"></a></div>
  <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>

  
<section id = "relate">
	
                <div id="null"></div>
	
</section>


  
    <section id="comment">
    <!--   <h1 class="title">留言</h1> -->
    
    
        <!-- 多说评论框 start -->
        <div class="ds-thread" data-thread-key="2017/05/12/My-First-Bolg/" data-title="WebView 全面使用攻略" data-url="https://github.com/EteVan/etevan.github.io.git/2017/05/12/My-First-Bolg/"></div>
        <!-- 多说评论框 end -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <script type="text/javascript">
        var duoshuoQuery = {short_name:"lupeng-test"};
          (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] 
             || document.getElementsByTagName('body')[0]).appendChild(ds);
          })();
          </script>
        <!-- 多说公共JS代码 end -->

      
    </section>




</div></div>
      <aside id="sidebar" class="alignright">
   


  <div class="widget tag">
  <h3 class="title">微信公众账号</h3>
    <ul class="entry">
      <img src="/img/default/qrcode.jpg" alt="欢迎关注，该账号供个人学习使用，偶尔做一些开发尝试，更新频率较低。" style= "width: 100%">
    </ul>
</div>

  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>


  
<div class="widget">
  <h3 class="title">最新评论</h3>
  	<!-- 多说最新评论 start -->
	<div class="ds-recent-comments ds-recent-user" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
	<!-- 多说最新评论 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"lupeng-test"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
	<!-- 多说公共JS代码 end -->
</div>



  


  

  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/etevan.github.io/archives/2017/">公元 2017 年</a><span class="archive-list-count">2</span></li></ul>
  </div>

</aside>
      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2017 EteVan
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>
  
  <div class="visit">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/etevan.github.io/js/jquery.imagesloaded.min.js"></script>
<script src="/etevan.github.io/js/gallery.js"></script>

<!-- calendar widget -->

  <script src="/etevan.github.io/js/calendar.js"></script>
  <script src="/etevan.github.io/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'calendar'});
    
    });
  </script>


<!-- 『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- wumii关联推荐 -->
<script type="text/javascript" src="http://widget.wumii.cn/ext/relatedItemsWidget"></script>

<!-- 百度推荐 -->

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>

<!-- 站内搜索-Swiftype -->
<!-- <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','sC-iNFrvTTNtiXEVNwo1','2.0.0');
</script> -->

<!-- fancybox -->

<link rel="stylesheet" href="/etevan.github.io/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/etevan.github.io/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
